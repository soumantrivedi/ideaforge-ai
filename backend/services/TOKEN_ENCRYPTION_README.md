# Token Encryption Service

## Overview

The token encryption service provides Fernet-based symmetric encryption for securely storing McKinsey SSO refresh tokens in Redis. This ensures that refresh tokens are encrypted at rest and cannot be read without the encryption key.

## Features

- **Fernet Encryption**: Uses AES 128 in CBC mode with HMAC for authentication
- **Secure Key Management**: Loads encryption key from environment variables
- **Error Handling**: Comprehensive error handling with custom exceptions
- **Logging**: Structured logging for all operations
- **Convenience Functions**: Global service instance with helper functions

## Setup

### Generate Encryption Key

Generate a secure 32-byte URL-safe base64-encoded encryption key:

```bash
python -c 'from cryptography.fernet import Fernet; print(Fernet.generate_key().decode())'
```

### Configure Environment

Set the encryption key in your environment:

```bash
export MCKINSEY_TOKEN_ENCRYPTION_KEY="your-generated-key-here"
```

Or add to your `.env` file:

```
MCKINSEY_TOKEN_ENCRYPTION_KEY=your-generated-key-here
```

### Kubernetes Secret

For Kubernetes deployments, create a secret:

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: mckinsey-sso-secrets
  namespace: ideaforge-ai
type: Opaque
stringData:
  mckinsey-token-encryption-key: "your-generated-key-here"
```

## Usage

### Basic Usage

```python
from backend.services.token_encryption import TokenEncryptionService

# Initialize service (loads key from settings)
service = TokenEncryptionService()

# Encrypt a refresh token
refresh_token = "mckinsey_refresh_token_abc123"
encrypted = service.encrypt_token(refresh_token)

# Decrypt the token
decrypted = service.decrypt_token(encrypted)
assert decrypted == refresh_token
```

### Using Convenience Functions

```python
from backend.services.token_encryption import (
    encrypt_refresh_token,
    decrypt_refresh_token
)

# Encrypt
encrypted = encrypt_refresh_token("my_refresh_token")

# Decrypt
decrypted = decrypt_refresh_token(encrypted)
```

### Custom Encryption Key

```python
from backend.services.token_encryption import TokenEncryptionService

# Use a custom key (useful for testing)
service = TokenEncryptionService(encryption_key="your-custom-key")
```

## Error Handling

The service raises `TokenEncryptionError` for all encryption/decryption failures:

```python
from backend.services.token_encryption import (
    TokenEncryptionService,
    TokenEncryptionError
)

try:
    service = TokenEncryptionService()
    encrypted = service.encrypt_token("my_token")
except TokenEncryptionError as e:
    print(f"Encryption failed: {e}")
```

### Common Errors

1. **Missing Encryption Key**
   ```
   TokenEncryptionError: Token encryption key not configured.
   Set MCKINSEY_TOKEN_ENCRYPTION_KEY environment variable.
   ```
   **Solution**: Set the `MCKINSEY_TOKEN_ENCRYPTION_KEY` environment variable.

2. **Invalid Key Format**
   ```
   TokenEncryptionError: Invalid encryption key format.
   Key must be a 32-byte URL-safe base64-encoded string.
   ```
   **Solution**: Generate a new key using the command above.

3. **Decryption Failure**
   ```
   TokenEncryptionError: Token decryption failed: Invalid token or wrong encryption key
   ```
   **Solution**: Ensure you're using the same key that was used for encryption.

## Security Considerations

1. **Key Storage**: Never commit encryption keys to version control
2. **Key Rotation**: Plan for key rotation by supporting multiple keys
3. **Key Length**: Always use 32-byte keys generated by Fernet
4. **Transport**: Encrypted tokens should still be transmitted over HTTPS
5. **Access Control**: Limit access to the encryption key to authorized services only

## Testing

Run the verification script to test the encryption service:

```bash
# Generate a test key
export MCKINSEY_TOKEN_ENCRYPTION_KEY=$(python -c 'from cryptography.fernet import Fernet; print(Fernet.generate_key().decode())')

# Run basic Fernet test
python backend/test_token_encryption_simple.py
```

## Integration with McKinsey SSO

The token encryption service is used by the McKinsey SSO implementation to:

1. Encrypt refresh tokens before storing in Redis
2. Decrypt refresh tokens when refreshing access tokens
3. Ensure tokens are never stored in plaintext

Example integration:

```python
from backend.services.token_encryption import encrypt_refresh_token, decrypt_refresh_token
from backend.services.redis_cache import redis_cache

# Store encrypted refresh token
refresh_token = "mckinsey_refresh_token_abc123"
encrypted_token = encrypt_refresh_token(refresh_token)
await redis_cache.set(f"mckinsey:tokens:{user_id}", {
    "refresh_token_encrypted": encrypted_token,
    "expires_at": expires_at
})

# Retrieve and decrypt refresh token
token_data = await redis_cache.get(f"mckinsey:tokens:{user_id}")
refresh_token = decrypt_refresh_token(token_data["refresh_token_encrypted"])
```

## Requirements

- Python 3.9+
- cryptography >= 43.0.1
- structlog >= 24.4.0

## References

- [Cryptography Fernet Documentation](https://cryptography.io/en/latest/fernet/)
- [OAuth 2.0 Security Best Practices](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-security-topics)
- Requirements: 3.4 (from oauth2-oidc-auth spec)
